## Функции высшего порядка

Функции являются значениями. Их можно:

 - сохранять в переменную
 - передавать в аргументах
 - возвращать из функции

higher-order functions функции, которые принимают в аргументах другие функции, или возвращают другие функции.

В модуле lists много функций высшего порядка. **lists:map/2** и **lists:filter/2**.

**map** применяет переданную функцию к каждому элементу списка и возвращает
новый список.

```erlang
1> List = [1,2,3,4,5].
[1,2,3,4,5]
2> F = fun(Val) -> Val * 2 end.
 #Fun<erl_eval.6.90072148>
3> lists:map(F, List).
[2,4,6,8,10]
```

```erlang
4> List2 = [{user, 1, "Bob"}, {user, 2, "Bill"}, {user, 3, "Helen"}].
[{user,1,"Bob"},{user,2,"Bill"},{user,3,"Helen"}]
5> F2 = fun({user, Id, Name}) -> {user, Id, string:to_upper(Name)} end.
 #Fun<erl_eval.6.90072148>
6> lists:map(F2, List2).
[{user,1,"BOB"},{user,2,"BILL"},{user,3,"HELEN"}]
```

**filter** использует переданную функцию как предикат для фильтрации списка.

```erlang
7> lists:filter(fun(Val) -> Val > 3 end, List).
[4,5]
8> lists:filter(fun({user, Id, _}) -> Id rem 2 =:= 0 end, List2).
[{user,2,"Bill"}]
```

Примеры из прошлого урока переписать их с использованием map и filter.

Вспомним список пользователей, с которым мы работали:

```erlang
get_users() ->
    [{user, 1, "Bob", male, 22},
     {user, 2, "Helen", female, 14},
     {user, 3, "Bill", male, 11},
     {user, 4, "Kate", female, 18}].
```

Фильтрация пользователей по полу:

```erlang
get_females(Users) ->
    F = fun({user, _, _, male, _}) -> false;
           ({user, _, _, female, _}) -> true
        end,
    lists:filter(F, Users).
```

Получение id и name пользователя:

```erlang
get_id_name(Users) ->
    F = fun({user, Id, Name, _, _}) -> {Id, Name} end,
    lists:map(F, Users).
```

**map** и **filter** по очереди:

```erlang
get_females_id_name(Users) ->
    Users2 = lists:filter(fun({user, _, _, Gender, _}) -> Gender =:= female end, Users),
    lists:map(fun({user, Id, Name, _, _}) -> {Id, Name} end, Users2).
```

2 прохода по списку

**lists:filtermap/2** в один проход

```erlang
get_females_id_name2(Users) ->
    lists:filtermap(fun({user, _, _, male, _}) -> false;
                       ({user, Id, Name, female, _}) -> {true, {Id, Name}}
                    end, Users).
```

Есть много примеров, где функция передается аргументом в другую функцию.
Редко бывает, чтобы функция возвращалась как значение.

В **EUnit**, фреймворке для модульного тестирования, используются
генераторы юнит тестов.  Они возвращают список функций.

Callback для подписки на события

Примеров мало, и это не повседневная практика, а какие-то особые случаи.

Можно реализовать ленивые вычисления, об этом в 9-й главе книги Чезарини.


## Свертка

Map принимает список, и возвращает список.
Свертка принимает список, и возвращает одно значение -- "сворачивает" список.

**lists:foldl/3** принимает 3 аргумента:

 - функцию сворачивания
 - начальное значение аккумулятора
 - список

Функция сворачивания:
 - принимает текущий элемент списка
 - и текущее значение аккумулятора
 - и должна вернуть новое значение аккумулятора.

```erlang
1> List = [1,2,3,4,5].
[1,2,3,4,5]
2> lists:foldl(fun(Item, Acc) -> Acc + Item end, 0, List).
15
3> lists:foldl(fun(Item, Acc) -> Acc * Item end, 1, List).
120
```

```erlang
get_users() ->
    [{user, 1, "Bob", male, 22},
     {user, 2, "Helen", female, 14},
     {user, 3, "Bill", male, 11},
     {user, 4, "Kate", female, 18}].
```

Соберем статистику по пользователям.

В качестве аккумулятора возьмем кортеж из 4х чисел:

```erlang
{Males, Females, TotalUsers, TotalAge}
```

Как результат свертки получим этот кортеж, заполненный актуальными данными.

```erlang
get_stat(Users) ->
    F = fun({user, _, _, Gender, Age}, {Males, Females, TotalUsers, TotalAge}) ->
                case Gender of
                    male -> {Males + 1, Females, TotalUsers + 1, TotalAge + Age};
                    female -> {Males, Females + 1, TotalUsers + 1, TotalAge + Age}
                end
        end,
    lists:foldl(F, {0, 0, 0, 0}, Users).
```

Пробуем применить:

```erlang
1> Users = main:get_users().
[{user,1,"Bob",male,22},
 {user,2,"Helen",female,14},
 {user,3,"Bill",male,11},
 {user,4,"Kate",female,18}]
2> {M, F, TU, TA} = main:get_stat(Users).
{2,2,4,65}
```

Средний возраст сразу не получим, но получим данные, чтобы его рассчитать.

```erlang
3> TA / TU.
16.25
```

Все, что можно реализовать через рекурсивные функции с аккумуляторами, можно реализовать и через свертку.

```erlang
split_by_age(Users) -> split_by_age(Users, {[], []}).

split_by_age([], {Acc1, Acc2}) -> {lists:reverse(Acc1), lists:reverse(Acc2)};

split_by_age([User | Rest], {Acc1, Acc2}) ->
    {user, _, _, _, Age} = User,
    if
        Age < 18 -> split_by_age(Rest, {[User | Acc1], Acc2});
        true -> split_by_age(Rest, {Acc1, [User | Acc2]})
    end.
```

Вот как можно сделать тоже самое через свертку:

```erlang
split_by_age(Users) ->
    lists:foldl(fun(User, {Acc1, Acc2}) ->
                        {user, _, _, _, Age} = User,
                        if
                            Age < 18 -> {[User | Acc1], Acc2};
                            true -> {Acc1, [User | Acc2]}
                        end
                end,
                {[], []},
                Users).
```

Рекомендуется применять именно свертку вместо кастомных рекурсивных функций.
Выше уровень абстракции, значит меньше кода.
Меньше кода, значит меньше возможностей допустить ошибку.

Свертка бывает левая и правая: lists:foldl/3, lists:foldr/3.

Левая свертка реализована с хвостовой рекурсией, а правая с обычной рекурсией.


## Конструкторы списков

lists comprehention -- еще один высокоуровневый способ работы со списками.

Синтаксис напрямую заимствуется из математики.

```
{x | x ∈ N, x > 0}
```

означает: из множества натуральных чисел (N), взять каждый элемент (x), больший нуля.

```erlang
1> List = [-2,-1,0,1,2].
[-2,-1,0,1,2]
2> [X || X <- List, X > 0].
[1,2]
```

Конструкторы списков делают то же, что map и filter. filter мы уже увидели, а вот map:

```erlang
3> [X * 2 || X <- List].
[-4,-2,0,2,4]
```

Конечно, можно объединять и то, и другое в одном проходе:

```erlang
4> [X * 2 || X <- List, X > 0].
[2,4]
```

Можно работать с несколькими списками одновременно:

```erlang
5> List1 = [1,2].
[1,2]
6> List2 = [a,b].
[a,b]
7> List3 = [cc,dd].
[cc,dd]
8> [{X,Y,Z} || X <- List1, Y <- List2, Z <- List3].
[{1,a,cc}, {1,a,dd}, {1,b,cc}, {1,b,dd}, {2,a,cc}, {2,a,dd}, {2,b,cc}, {2,b,dd}]
```

Как видно, элементы списков соединяются "каждый с каждым".

Ну и, конечно, все эти списки можно фильтровать:

```erlang
9> [{X,Y,Z} || X <- List1, X > 1, Y <- List2, Y =/= a, Z <- List3].
[{2,b,cc},{2,b,dd}]
```

Если элементы списка -- сложные структуры, то можно извлекать значения
внутри них, и вычислять что-то на основе этих внутренних значений.

```erlang
1> List = [{rect, 5, 10}, {rect, 4, 8}, {rect, 4, 3}].
[{rect,5,10},{rect,4,8},{rect,4,3}]
2> [{area, W * H} || {rect, W, H} <- List].
[{area,50},{area,32},{area,12}]
```

И фильтровать можно по внутренним значениям и по производным от них выражениям:

```erlang
3> [{area, W * H} || {rect, W, H} <- List, W * H < 40].
[{area,32},{area,12}]
```

Давайте опять вернемся к нашему списку пользователей:

```erlang
get_users() ->
    [{user, 1, "Bob", male, 22},
     {user, 2, "Helen", female, 14},
     {user, 3, "Bill", male, 11},
     {user, 4, "Kate", female, 18}].
```

Отфильтруем по полу с помощью конструкторов списков:

```erlang
[User || {user, _, _, Gender, _} = User <- Users, Gender =:= female].
```

И извлечем {Id, Name} так же:

```erlang
[{Id, Name} || {user, Id, Name, _, _} <- Users].
```

Пример из книги Джо Армстронга с пифагоровыми тройками.

Вспомним теорему Пифагора: сумма квадратов катетов равна квадрату гипотенузы.

Существует не так много вариантов, когда длины катетов и гипотенузы
выражаются целыми числами. Самый известный такой вариант: {3, 4, 5}.

Найти все такие варианты с помощью конструкторов списков.

На входе дана максимальная длина гипотенузы, на выходе нужно
получить список всех возможных троек **{Катет, Катет, Гипотенуза}**.

Берем список всех возможных длин:

```erlang
1> Max = 20.
20
2> Lengthes = lists:seq(1, Max).
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
```

И генерируем все возможные сочетания длин:

```erlang
3> [{X,Y,Z} || X <- Lengthes, Y <- Lengthes, Z <- Lengthes].
[{1,1,1}, {1,1,2}, {1,1,3}, ...
```

Промежуточный результат получится очень большой, но это не важно. Дальше его нужно отфильтровать.

```erlang
4> [{X,Y,Z} || X <- Lengthes, Y <- Lengthes, Z <- Lengthes, X * X + Y * Y =:= Z * Z].
[{3,4,5}, {4,3,5}, {5,12,13}, {6,8,10}, {8,6,10}, {8,15,17}, {9,12,15}, {12,5,13}, {12,9,15}, {12,16,20}, {15,8,17}, {16,12,20}]
```

Задача решена одной строкой кода :)
